<head>
    <style>
        html, body, #canvas {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            display: block;
        }
        .error {
            font-family: Consolas;
            font-size: 1.2em;
            color: black;
            box-sizing: border-box;
            background-color: lightcoral;
            border-radius: 2px;
            border-color: lightblue;
            border-width: thin;
            border-style: solid;
            line-height: 1.4em;
        }
        .error:hover {
            color: black;
            background-color: brown;
            border-color: blue;
        }
        #message {
            font-family: Consolas;
            font-size: 1.2em;
            color: #ccc;
            background-color: black;
            font-weight: bold;
            z-index: 2;
            position: absolute;
        }
    </style>
</head>
<body>
    <div id="message"></div>
    <div id="container"></div>

</body>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/95/three.min.js"></script>
<canvas id="canvas"></canvas>


<script id="Untitled-1" type="x-shader/x-fragment">
    uniform vec3        iResolution;
    uniform float       iGlobalTime;
    uniform float       iTime;
    uniform float       iTimeDelta;
    uniform int         iFrame;
    uniform float       iChannelTime[4];
    uniform vec3        iChannelResolution[4];
    uniform vec4        iMouse;
    uniform sampler2D   iChannel0;
    uniform sampler2D   iChannel1;
    uniform sampler2D   iChannel2;
    uniform sampler2D   iChannel3;
    uniform sampler2D   iChannel4;
    uniform sampler2D   iChannel5;
    uniform sampler2D   iChannel6;
    uniform sampler2D   iChannel7;
    uniform sampler2D   iChannel8;
    uniform sampler2D   iChannel9;

    #define SHADER_TOY
    
    void main() {
        gl_FragColor = vec4(1.0, 0.0, 0.0, 0.0);
    }
</script>

<script type="text/javascript">
    var currentShader = {};
    (function(){
        console.error = function (message) {
            if('7' in arguments) {
                $("#message").append('<h3>Shader failed to compile - ' + currentShader.Name + '</h3><ul>')
                $("#message").append(arguments[7].replace(/ERROR: \d+:(\d+)/g, function(m, c) {
                    return '<li><a class="error" unselectable href="'+ encodeURI('command:shader-toy.onGlslError?' + JSON.stringify([Number(c) - currentShader.LineOffset, currentShader.File])) + '">Line ' + String(Number(c) - currentShader.LineOffset) + '</a>';
                }));
                $("#message").append('</ul>');
            }
        };
    })();

    var canvas = document.getElementById('canvas');
    var renderer = new THREE.WebGLRenderer({canvas: canvas, antialias: true});
    var clock = new THREE.Clock();
    var resolution = new THREE.Vector3(canvas.clientWidth, canvas.clientHeight, 1.0);
    var mouse = new THREE.Vector4(0, 0, 0, 0);
    var frameCounter = 0;

    var channelResolution = new THREE.Vector3(128.0, 128.0, 0.0);

    var buffers = [];
    buffers.push({
        Name: "Untitled-1",
        File: "Untitled-1",
        LineOffset: "121",
        Target: null,
        Shader: new THREE.ShaderMaterial({
            fragmentShader: document.getElementById('Untitled-1').textContent,
            depthWrite: false,
            depthTest: false,
            uniforms: {
                iResolution: { type: "v3", value: resolution },
                iGlobalTime: { type: "f", value: 0.0 },
                iTime: { type: "f", value: 0.0 },
                iTimeDelta: { type: "f", value: 0.0 },
                iFrame: { type: "i", value: 0 },
                iMouse: { type: "v4", value: mouse },
            }
        })
    });
    
    var scene = new THREE.Scene();
    var quad = new THREE.Mesh(
        new THREE.PlaneGeometry(resolution.x, resolution.y),
        null
    );
    scene.add(quad);
    
    var camera = new THREE.OrthographicCamera(-resolution.x / 2.0, resolution.x / 2.0, resolution.y / 2.0, -resolution.y / 2.0, 1, 1000);
    camera.position.set(0, 0, 10);

    // Run every shader once to check for compile errors
    for (let i in buffers) {
        let buffer = buffers[i];
        currentShader = {
            Name: buffer.Name,
            File: buffer.File,
            LineOffset: buffer.LineOffset
        };
        quad.material = buffer.Shader;
        renderer.render(scene, camera, buffer.Target);
    }
    currentShader = {};

    render();

    function render() {
        requestAnimationFrame(render);
        if (canvas.width !== canvas.clientWidth || canvas.height !== canvas.clientHeight) {
            resolution.x = canvas.clientWidth;
            resolution.y = canvas.clientHeight;
            for (let i in buffers) {
                if (buffers[i].Target) {
                    buffers[i].Target.setSize(resolution.x, resolution.y);
                }
            }
            renderer.setSize(resolution.x, resolution.y, false);
            
            // Update Camera and Mesh
            quad.geometry = new THREE.PlaneGeometry(resolution.x, resolution.y);
            camera.left = -resolution.x / 2.0;
            camera.right = resolution.x / 2.0;
            camera.top = resolution.y / 2.0;
            camera.bottom = -resolution.y / 2.0;
            camera.updateProjectionMatrix();
        }
        
        frameCounter++;
        var deltaTime = clock.getDelta();
        var time = clock.getElapsedTime();
        
        for (let i in buffers) {
            let buffer = buffers[i];
            buffer.Shader.uniforms['iResolution'].value = resolution;
            buffer.Shader.uniforms['iTimeDelta'].value = deltaTime;
            buffer.Shader.uniforms['iGlobalTime'].value = time;
            buffer.Shader.uniforms['iTime'].value = time;
            buffer.Shader.uniforms['iFrame'].value = frameCounter;
            buffer.Shader.uniforms['iMouse'].value = mouse;

            quad.material = buffer.Shader;
            renderer.render(scene, camera, buffer.Target);
        }
    }
    canvas.addEventListener('mousemove', function(evt) {
        if (mouse.z + mouse.w != 0) {
            var rect = canvas.getBoundingClientRect();
            mouse.x = evt.clientX - rect.left;
            mouse.y = resolution.y - evt.clientY - rect.top;
        } 
    }, false);
    canvas.addEventListener('mousedown', function(evt) {
        if (evt.button == 0)
            mouse.z = 1;
        if (evt.button == 2)
            mouse.w = 1;
    }, false);
    canvas.addEventListener('mouseup', function(evt) {
        if (evt.button == 0)
            mouse.z = 0;
        if (evt.button == 2)
            mouse.w = 0;
    }, false);
</script>